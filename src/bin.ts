/**
 * Emits TS code that renders all templates in the given folder (or current dir).
 */

import { buildTemplate } from './build.ts';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { parseArgs } from 'node:util';

const opts = parseArgs({
  args: process.argv,
  options: {
    import: {
      type: 'boolean',
      short: 'i',
    },
    repeatable: {
      type: 'boolean',
      short: 'r',
    },
  },
  allowPositionals: true,
});

const all = allPaths(opts.positionals.slice(2));
if (!all.length) {
  throw new Error(`found no templates?`);
}

let out: string[] = [];

out.push('// Generated by html-template-compiler\n');
if (!opts.values.repeatable) {
  out.push(`// ${new Date()}\n`);
}
out.push('\n');

if (opts.values.import) {
  // import from this package
  out.push(`import { unsafe, escape, ifDefined, renderBody } from 'html-template-compiler';\n`);
} else {
  // embed this package
  let raw: string;

  try {
    // deployed ver, nested
    const u = new URL('./src/lib.ts', import.meta.url);
    raw = fs.readFileSync(u, 'utf-8');
  } catch (e) {
    const u = new URL('./lib.ts', import.meta.url);
    raw = fs.readFileSync(u, 'utf-8');
  }

  raw = raw.replaceAll(/^export /gm, '');
  out.push(raw);
}

out.push(`\n// ${all.length} templates`);

const seenNames = new Set<string>();

for (const c of all) {
  const raw = fs.readFileSync(c, 'utf-8');
  const { template, typeString } = buildTemplate(raw);

  const { name } = path.parse(c);
  const cc = toCamelCase(name);
  if (seenNames.has(cc)) {
    throw new Error(`duplicate name: ${name} => ${cc}`);
  }
  seenNames.add(cc);

  out.push(
    `\n\nexport const template${cc} = (context: ${typeString}): { toString(): string } => unsafe(${template});`,
  );
}

process.stderr.write(`Generated ${seenNames.size} templates\n`);
process.stdout.write(out.join(''));

function toCamelCase(raw: string) {
  const parts = raw.split(/\W+/).filter((x) => x);
  if (!parts.length) {
    throw new Error(`can't camel-case from: ${raw}`);
  }

  return parts.map((p) => p[0].toUpperCase() + p.substring(1)).join('');
}

function allPaths(src: string[]) {
  const out: string[] = [];

  for (const s of src) {
    try {
      const contents = fs.readdirSync(s);

      for (const c of contents) {
        if (c.endsWith('.html')) {
          out.push(path.join(s, c));
        }
      }
    } catch (e) {
      // probably file
      out.push(s);
    }
  }

  return out;
}
