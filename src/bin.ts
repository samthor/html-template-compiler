/**
 * Emits TS code that renders all templates in the given folder (or current dir).
 */

import { buildTemplate } from './build.ts';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { parseArgs } from 'node:util';
import { getLibNames } from './scriptinfo.ts';

const opts = parseArgs({
  args: process.argv,
  options: {
    inline: {
      // whether to inline code (true), or import from this package (false, default)
      type: 'boolean',
      short: 'i',
    },
    date: {
      // include the date (makes output constantly change)
      type: 'boolean',
      short: 'd',
    },
  },
  allowPositionals: true,
});

const all = allPaths(opts.positionals.slice(2));
if (!all.length) {
  throw new Error(`found no templates?`);
}

let out: string[] = [];

out.push('// Generated by html-template-compiler\n');
if (opts.values.date) {
  out.push(`// ${new Date()}\n`);
}
out.push('\n');

if (opts.values.inline) {
  // embed this package
  const u = new URL('./lib.ts', import.meta.url);
  let raw = fs.readFileSync(u, 'utf-8');

  // TODO: very lazy "non export" version
  raw = raw.replaceAll(/^export /gm, '');
  out.push(raw);
} else {
  // import from this package
  const libNames = await getLibNames();
  out.push(`import { ${libNames.join(', ')} } from 'html-template-compiler';\n`);
}

out.push(`\n// ${all.length} templates`);

const seenNames = new Set<string>();

for (const c of all) {
  const raw = fs.readFileSync(c, 'utf-8');
  const { template, typeString, anyRequired } = buildTemplate(raw);

  const { name } = path.parse(c);
  const cc = toCamelCase(name);
  if (seenNames.has(cc)) {
    throw new Error(`duplicate name: ${name} => ${cc}`);
  }
  seenNames.add(cc);
  const qualifier = anyRequired ? '' : '?';

  out.push(
    `

export type Template${cc} = ${typeString};
export const template${cc} = (context${qualifier}: Template${cc}): { toString(): string } => unsafe(${template});`,
  );
}

process.stderr.write(`Generated ${seenNames.size} templates\n`);
process.stdout.write(out.join(''));

function toCamelCase(raw: string) {
  const parts = raw.split(/\W+/).filter((x) => x);
  if (!parts.length) {
    throw new Error(`can't camel-case from: ${raw}`);
  }

  return parts.map((p) => p[0].toUpperCase() + p.substring(1)).join('');
}

function allPaths(src: string[]) {
  const out: string[] = [];

  for (const s of src) {
    try {
      const contents = fs.readdirSync(s);

      for (const c of contents) {
        if (c.endsWith('.html')) {
          out.push(path.join(s, c));
        }
      }
    } catch (e) {
      // probably file
      out.push(s);
    }
  }

  return out;
}
